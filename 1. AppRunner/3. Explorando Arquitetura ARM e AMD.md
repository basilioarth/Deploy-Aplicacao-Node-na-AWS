**Resumo da Aula: Resolu√ß√£o de Problemas de Arquitetura e Deploy no AWS App Runner**  

---

### **Contexto e Problema Encontrado**  
- **Objetivo**: Fazer deploy de uma aplica√ß√£o Dockerizada no **AWS App Runner** ap√≥s adicionar uma rota `/health` para health checks.  
- **Erro Cr√≠tico**: A aplica√ß√£o falhou ao subir devido a um **mismatch de arquitetura** (imagem constru√≠da em ARM64 no Mac M1, enquanto o App Runner usa AMD64).  
- **Sintomas**:  
  - Health checks falharam (erro `TCP`).  
  - Logs do App Runner indicaram falha na inicializa√ß√£o do container.  

---

### **Solu√ß√£o do Problema**  

#### **1. Identifica√ß√£o da Causa**  
- **Docker Inspect**: Verificou-se que a imagem foi constru√≠da para ARM64 (`linux/arm64`), incompat√≠vel com a arquitetura do App Runner (`linux/amd64`).  
- **Comando de Build Corrigido**:  
  ```bash  
  docker build --platform linux/amd64 -t widget-server:v5 .  
  ```  
  - Especifica√ß√£o expl√≠cita da plataforma `linux/amd64` no build.  

#### **2. Novo Fluxo de Deploy**  
1. **Build e Tag da Imagem**:  
   ```bash  
   docker build --platform linux/amd64 -t widget-server:v5 .  
   docker tag widget-server:v5 <ECR-URI>/widget-server:v5  
   ```  
2. **Push para o ECR**:  
   ```bash  
   docker push <ECR-URI>/widget-server:v5  
   ```  
3. **Atualiza√ß√£o no App Runner**:  
   - Acessar o servi√ßo no Console AWS > App Runner > *Configuration* > Editar URI da imagem para `v5`.  

---

### **Principais Li√ß√µes**  

#### **1. Plataforma no Docker Build**  
- **Problema Comum**: Imagens constru√≠das em Mac M1 (ARM) falham em ambientes AMD64 (ex: AWS).  
- **Boas Pr√°ticas**:  
  - Sempre especificar `--platform linux/amd64` em builds locais se o target for cloud.  
  - Em CI/CD (ex: GitHub Actions), garantir que o runner use `ubuntu-latest` (AMD64 por padr√£o).  

#### **2. Health Checks no App Runner**  
- **Configura√ß√£o Atual**:  
  - Protocolo: `TCP` (verifica apenas se a porta est√° aberta).  
  - **Limita√ß√£o**: N√£o valida funcionalidade real da aplica√ß√£o.  
- **Melhoria Proposta**:  
  - Usar `HTTP` e criar uma rota `/health` que retorne `200 OK` (implementado na aplica√ß√£o).  

#### **3. Logs e Observabilidade**  
- **Application Logs**: Acess√≠veis via Console AWS > App Runner > *Application Logs*.  
- **M√©tricas Built-in**: Requisi√ß√µes, status HTTP, lat√™ncia (dispon√≠veis na aba *Metrics*).  

---

### **Pr√≥ximos Passos**  

#### **1. Automatiza√ß√£o do Deploy via CI/CD**  
- **GitHub Actions**:  
  - Pipeline para build, push da imagem e atualiza√ß√£o autom√°tica no App Runner.  
  - Exemplo de workflow:  
    ```yaml  
    - name: Build and Push Docker Image  
      run: |  
        docker build --platform linux/amd64 -t ${{ secrets.ECR_URI }}:${{ github.sha }} .  
        docker push ${{ secrets.ECR_URI }}:${{ github.sha }}  
    ```  

#### **2. Health Check HTTP**  
- **Implementa√ß√£o**:  
  ```typescript  
  // Nova rota GET /health  
  app.get('/health', (req, res) => {  
    res.status(200).json({ status: 'OK' });  
  });  
  ```  
- **Configura√ß√£o no App Runner**:  
  - Alterar protocolo para `HTTP` e path para `/health`.  

#### **3. Custom Domains e HTTPS**  
- **Route 53**: Associar dom√≠nio personalizado ao App Runner.  
- **Certificado SSL**: Autom√°tico via AWS Certificate Manager (ACM).  

---

### **C√≥digo Relevante**  

#### **Docker Build com Plataforma Espec√≠fica**  
```bash  
# Build para AMD64 (evita erro de arquitetura)  
docker build --platform linux/amd64 -t widget-server:v5 .  
```  

#### **Health Check HTTP (Exemplo)**  
```typescript  
import { Router } from 'express';  

const healthCheckRouter = Router();  

healthCheckRouter.get('/', (req, res) => {  
  res.status(200).json({ status: 'OK' });  
});  

export { healthCheckRouter };  
```  

---

**Conclus√£o**:  
A aula refor√ßou a import√¢ncia de **especificar a plataforma no Docker build** e validar health checks robustos. A corre√ß√£o do mismatch de arquitetura permitiu o deploy bem-sucedido no App Runner, e a pr√≥xima etapa ser√° automatizar o processo via CI/CD e ajustar o health check para HTTP. Nos pr√≥ximos m√≥dulos, exploraremos observabilidade avan√ßada e dom√≠nios personalizados! üöÄ